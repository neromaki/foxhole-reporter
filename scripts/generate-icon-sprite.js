#!/usr/bin/env node
/**
 * Generate icon sprite atlas from individual icon files using Sharp.
 * Resizes icons to standard size, optimizes them, and creates sprite atlas.
 * Creates a single sprite image and metadata JSON for efficient loading.
 */

import sharp from 'sharp';
import { readFileSync, writeFileSync, readdirSync, mkdirSync } from 'fs';
import { join, basename } from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const ICONS_DIR = join(__dirname, '../src/map/icons');
const TEMP_DIR = join(__dirname, '../.temp-icons');
const OUTPUT_SPRITE = join(__dirname, '../public/icon-sprite.png');
const OUTPUT_METADATA = join(__dirname, '../src/data/icon-sprite.ts');

// Import ICON_SIZE from appConfig - for build script, read directly from source
const appConfigPath = join(__dirname, '../src/lib/appConfig.ts');
const appConfigSource = readFileSync(appConfigPath, 'utf-8');
const iconSizeMatch = appConfigSource.match(/export const ICON_SIZE = (\d+);/);
const ICON_SIZE = iconSizeMatch ? parseInt(iconSizeMatch[1], 10) : 32;

const COLUMNS = 16; // Icons per row in sprite
const PADDING = 2; // Padding between icons to prevent bleeding

async function preprocessIcons(files) {
  console.log('üîß Preprocessing icons (resize + optimize)...');
  
  // Create temp directory
  mkdirSync(TEMP_DIR, { recursive: true });
  
  const processedFiles = [];
  
  for (let i = 0; i < files.length; i++) {
    const file = files[i];
    const inputPath = join(ICONS_DIR, file);
    const outputPath = join(TEMP_DIR, file);
    
    try {
      // Resize to ICON_SIZE and optimize with pngquant-quality settings
      await sharp(inputPath)
        .resize(ICON_SIZE, ICON_SIZE, {
          fit: 'contain',
          background: { r: 0, g: 0, b: 0, alpha: 0 }
        })
        .png({
          quality: 90,
          compressionLevel: 9,
          adaptiveFiltering: true,
          palette: true // Use palette-based PNG for smaller size
        })
        .toFile(outputPath);
      
      processedFiles.push(file);
      
      if ((i + 1) % 20 === 0) {
        console.log(`  ‚úì Preprocessed ${i + 1}/${files.length} icons...`);
      }
    } catch (e) {
      console.warn(`  ‚ö†Ô∏è  Failed to preprocess ${file}:`, e.message);
    }
  }
  
  console.log(`‚úÖ Preprocessed ${processedFiles.length} icons`);
  return processedFiles;
}

async function main() {
  console.log('üé® Generating icon sprite atlas...');
  console.log(`üìè Using ICON_SIZE: ${ICON_SIZE}px`);
  
  const files = readdirSync(ICONS_DIR)
    .filter(f => f.endsWith('.png'))
    .sort(); // Consistent ordering
  
  if (files.length === 0) {
    console.error('‚ùå No PNG files found in', ICONS_DIR);
    process.exit(1);
  }
  
  // Preprocess icons (resize + optimize)
  const processedFiles = await preprocessIcons(files);

  const totalIcons = files.length;
  const rows = Math.ceil(totalIcons / COLUMNS);
  const spriteWidth = COLUMNS * (ICON_SIZE + PADDING);
  const spriteHeight = rows * (ICON_SIZE + PADDING);

  console.log(`üìä Creating sprite: ${spriteWidth}x${spriteHeight} (${totalIcons} icons in ${rows} rows)`);

  const metadata = {};
  const compositeImages = [];
  
  for (let i = 0; i < processedFiles.length; i++) {
    const file = processedFiles[i];
    const iconName = basename(file, '.png');
    const col = i % COLUMNS;
    const row = Math.floor(i / COLUMNS);
    const x = col * (ICON_SIZE + PADDING);
    const y = row * (ICON_SIZE + PADDING);

    try {
      // Add to composite array for Sharp (using preprocessed icons)
      compositeImages.push({
        input: join(TEMP_DIR, file),
        top: y,
        left: x
      });

      metadata[iconName] = {
        x,
        y,
        width: ICON_SIZE,
        height: ICON_SIZE
      };

      if ((i + 1) % 20 === 0) {
        console.log(`  ‚úì Added ${i + 1}/${totalIcons} icons to sprite...`);
      }
    } catch (e) {
      console.warn(`  ‚ö†Ô∏è  Failed to add ${file} to sprite:`, e.message);
    }
  }

  // Create sprite with Sharp
  await sharp({
    create: {
      width: spriteWidth,
      height: spriteHeight,
      channels: 4,
      background: { r: 0, g: 0, b: 0, alpha: 0 }
    }
  })
  .composite(compositeImages)
  .png()
  .toFile(OUTPUT_SPRITE);

  const stats = await sharp(OUTPUT_SPRITE).metadata();
  console.log(`‚úÖ Sprite saved: ${OUTPUT_SPRITE} (${stats.width}x${stats.height})`);

  // Generate TypeScript metadata module
  const tsOutput = `// Auto-generated by scripts/generate-icon-sprite.js
// DO NOT EDIT MANUALLY - Run 'npm run build:sprite' to regenerate

import { ICON_SIZE } from '../lib/appConfig';

export interface IconSpriteCoords {
  x: number;
  y: number;
  width: number;
  height: number;
}

export const ICON_SPRITE_PATH = '/foxhole-reporter/icon-sprite.png';

// Sprite atlas dimensions for background-size scaling
export const SPRITE_COLUMNS = ${COLUMNS};
export const SPRITE_ICON_SIZE = ${ICON_SIZE};
export const SPRITE_PADDING = ${PADDING};
export const SPRITE_WIDTH = ${spriteWidth};
export const SPRITE_HEIGHT = ${spriteHeight};

export const ICON_SPRITE_METADATA: Record<string, IconSpriteCoords> = ${JSON.stringify(metadata, null, 2)} as const;

// Helper to get CSS background-position
export function getIconSpritePosition(iconName: string): string {
  const coords = ICON_SPRITE_METADATA[iconName];
  if (!coords) return '0 0';
  return \`-\${coords.x}px -\${coords.y}px\`;
}

// Helper to get scaled CSS background-position for zoom levels
export function getIconSpritePositionScaled(iconName: string, scale: number): string {
  const coords = ICON_SPRITE_METADATA[iconName];
  if (!coords) return '0 0';
  const scaledX = coords.x * scale;
  const scaledY = coords.y * scale;
  return \`-\${scaledX}px -\${scaledY}px\`;
}

// Helper to check if icon exists in sprite
export function hasIconInSprite(iconName: string): boolean {
  return iconName in ICON_SPRITE_METADATA;
}

// Get all available icon names
export const AVAILABLE_ICONS = Object.keys(ICON_SPRITE_METADATA) as ReadonlyArray<string>;
`;

  writeFileSync(OUTPUT_METADATA, tsOutput, 'utf-8');
  console.log(`‚úÖ Metadata saved: ${OUTPUT_METADATA}`);
  console.log(`\nüì¶ Sprite atlas complete: ${totalIcons} icons packed into ${spriteWidth}x${spriteHeight}px`);
}

main().catch(err => {
  console.error('‚ùå Error:', err);
  process.exit(1);
});
