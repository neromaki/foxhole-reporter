#!/usr/bin/env node
/**
 * Pre-bundle territory SVG paths to eliminate runtime fetch + DOM parsing.
 * Extracts all <path> elements from #Territories group in each SVG.
 * Outputs: src/data/territory-paths.ts
 */

import { readFileSync, writeFileSync, readdirSync } from 'fs';
import { join, basename } from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const SUBREGIONS_DIR = join(__dirname, '../src/map/subregions');
const OUTPUT_FILE = join(__dirname, '../src/data/territory-paths.ts');

// Simple regex-based SVG parser (avoids DOMParser dependency in Node)
function extractTerritoryPaths(svgText) {
  const territoriesMatch = svgText.match(/<g id="Territories">([\s\S]*?)<\/g>/);
  if (!territoriesMatch) return null;

  const territoriesContent = territoriesMatch[1];
  const pathRegex = /<path\s+id="([^"]+)"[^>]*?\s+d="([^"]+)"[^>]*?\/>/g;
  const paths = [];
  let match;

  while ((match = pathRegex.exec(territoriesContent)) !== null) {
    paths.push({
      id: match[1],
      d: match[2]
    });
  }

  return paths;
}

function extractViewBox(svgText) {
  const match = svgText.match(/viewBox="([^"]+)"/);
  return match ? match[1] : '0 0 515 445'; // default fallback
}

function main() {
  console.log('üì¶ Bundling territory SVG paths...');
  
  const files = readdirSync(SUBREGIONS_DIR).filter(f => f.endsWith('.svg'));
  const regions = {};
  let totalPaths = 0;

  for (const file of files) {
    const filePath = join(SUBREGIONS_DIR, file);
    const svgText = readFileSync(filePath, 'utf-8');
    const filename = basename(file, '.svg');
    
    // Convert filename to region key (e.g., Kalokai.svg -> KalokaiHex, MarbanHollow -> MarbanHollow)
    const regionKey = filename === 'MarbanHollow' ? filename : `${filename}Hex`;
    
    const paths = extractTerritoryPaths(svgText);
    const viewBox = extractViewBox(svgText);
    
    if (!paths || paths.length === 0) {
      console.warn(`‚ö†Ô∏è  No territories found in ${file}`);
      continue;
    }

    regions[regionKey] = {
      viewBox,
      paths
    };

    totalPaths += paths.length;
    console.log(`‚úì ${regionKey}: ${paths.length} territories`);
  }

  // Generate TypeScript module
  const output = `// Auto-generated by scripts/bundle-territory-svgs.js
// DO NOT EDIT MANUALLY - Run 'npm run bundle:territories' to regenerate

export interface TerritoryPath {
  id: string;
  d: string;
}

export interface RegionData {
  viewBox: string;
  paths: TerritoryPath[];
}

export const TERRITORY_PATHS: Record<string, RegionData> = ${JSON.stringify(regions, null, 2)} as const;

// Region keys for convenience
export const REGION_KEYS = Object.keys(TERRITORY_PATHS) as ReadonlyArray<string>;
`;

  writeFileSync(OUTPUT_FILE, output, 'utf-8');
  
  console.log(`\n‚úÖ Bundled ${files.length} regions with ${totalPaths} total territories`);
  console.log(`üìÑ Output: ${OUTPUT_FILE}`);
}

main();
